<h3>使用二分法查找的rank的源码？</h3>

    import random,numpy as np,time,pandas as pd

    def rank(keys,k):       # 返回keys里小于k的值的个数。如果k也在keys里，则k=kyes[rank(keys,k)]
        print(keys)
        a,z=0,len(keys)-1
        x,y=a,z                
        while x<=y:
            m=int(x/2+y/2)
            #print(x,y,m)
            if keys[m]<k:
                x+=1
            elif keys[m]>k:
                y-=1
            else:
                return m
        return x

    a,b,k=1000,10,400
    keys=np.random.randint(a,size=(1,b))[0]
    keys.sort()
    print(rank(keys,k))

==============================================================

<h3>递归实现 get</h3>

    private Value get(Node x, Key key) {
        
        if(x == null)
            return null;//serach miss
        
        int cmp = key.compareTo(x.key);
        
        if(cmp < 0)
            return get(x.left, key);
        else if(cmp > 0)
            return get(x.right, key);
        else
            return x.val;//serach hit   
    }
    
<h3>非递归实现 get</h3>

    public Value get(Key key) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        Node cur = root;
        while(cur != null) {
            int cmp = key.compareTo(cur.key);
            if(cmp < 0)
                cur = cur.left;
            else if(cmp > 0)
                cur = cur.right;
            else
                return cur.val;//search hit
        }        
        return null;//search miss       
    }
    
==============================================================

<h3>递归实现 put。因为插入节点会更新二叉树信息（新建节点的父节点要更新size和left/right，后面的父节点要更新size），所以需要return节点，与其父节点更新信息。</h3>

    private Node put(Node x, Key key, Value val) {
        
        if(x == null) 
            return new Node(key, val, 1);
        
        int cmp = key.compareTo(x.key);
        
        if(cmp < 0)
            x.left = put(x.left, key, val);
        else if(cmp > 0) 
            x.right = put(x.right, key, val);
        else
            x.val = val;       
        x.size = size(x.left) + size(x.right) + 1;       
        return x;     
    }
    
<h3>非递归实现 get</h3>
    
    public void put(Key key, Value val) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        if(val == null) {
            delete(key);
            return;
        }
        
        if(root == null) {
            root = new Node(key, val);
            return;
        }
        
        boolean alreadyin = contains(key);//see if it needs to update the counts
        Node parent = null;
        Node cur = root;
        
        while(cur != null) {
            parent = cur;
            cur.size = alreadyin ? cur.size : cur.size + 1;//change size of cur
            
            int cmp = key.compareTo(cur.key);
            if(cmp < 0)
                cur = cur.left;
            else if(cmp > 0)
                cur = cur.right;
            else {
                cur.val = val;
                return;
            }
        }
        
        if(key.compareTo(parent.key) < 0)
            parent.left = new Node(key, val);
        else
            parent.right = new Node(key, val);       
    }
    
==============================================================

<h3>递归实现 floor，返回key小于等于k的x。 x.left.right!=x，而且一个元素右边的值都大于其左边的值，哪怕不是其子元素。
因为如果a在b左边，它们的一定在它们最近的共同的祖先元素的两侧，所以b一定大于a。
x.key==k到就返回x，小于就向右即x=x.right，否则就向左。但是有可能找不到，所以不能三种情况都直接return，
这里选择了右移处理找不到的情况，因为用左移动处理需要-1，即从k的右边穿越到k的左边</h3>

    private Node floor(Node x, Key key) {
        
        if(x == null)
            return null;
        
        int cmp = key.compareTo(x.key);
        
        if(cmp == 0)
            return x;
        if(cmp < 0)
            return floor(x.left, key);//in left subtree
        
        Node t = floor(x.right, key);//see if right subtree has a key is the floor(key)
        if(t != null)
            return t;//yes, return t
        else
            return x;//no, return x
            }
            

<h3>非递归实现 floor</h3>

     public Key floor(Key key) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        Node cur = root;
        Key result = null;
        
        while(cur != null) {//it works when BST is empty
            int cmp = key.compareTo(cur.key);
            
            if(cmp < 0) {
                cur = cur.left;
            }
            else if(cmp > 0) {
                result = cur.key;//may be updated
                cur = cur.right;//see if the right subtree has a key smaller than or equal to key
            }
            else {
                return cur.key;//final result
            }
        }
        return result;        
    }

==============================================================

<h3>递归实现 rank，返回key=k的节点前面有多少个节点。每次向右移时需要加上left.size+1</h3>

    private int rank(Node x, Key key) {
        
        if(x == null)
            return 0;
        
        int cmp = key.compareTo(x.key);
        
        if(cmp < 0)
            return rank(x.left, key);
        else if(cmp > 0)
            return size(x.left) + 1 + rank(x.right, key);
        else
            return size(x.left);        
    }

<h3>非递归实现 rank</h3>

    public int rank(Key key) {
        
        if(key == null) 
            throw new IllegalArgumentException("key is null");    
        
        Node cur = root;
        int result = 0;
        
        while(cur != null) {//work when BST is empty
            int cmp = key.compareTo(cur.key);
            
            if(cmp < 0) {
                cur = cur.left;
            }
            else if(cmp > 0) {
                result += size(cur.left) + 1;
                cur = cur.right;
            }
            else {
                return result + size(cur.left);
            }
        }
        
        return result;
       
    }
    
==============================================================

<h3>递归实现 select，返回x里key排在第k位的节点。每次向右移时要减去left.size和本身的长度（1）</h3> 

    private Node select(Node x, int k) {
        
        if(x == null)
            return null;
        
        int t = size(x.left);
        
        if(t > k)
            return select(x.left, k);
        else if(t < k)
            return select(x.right, k - t - 1);
        else
            return x;
        
    }

<h3>非递归实现 select</h3>

    public Key select(int k) {
        
        if(k < 0 || k >= size())//include the empty situation
            return null;
        
        Node cur = root;
        
        while(cur != null) {
            int less = size(cur.left);
            
            if(less < k) {
                cur = cur.right;
                k = k - less - 1;
            }
            else if(less > k) {
                cur = cur.left;
            }
            else {
                return cur.key;
            }
        }
        
        return null;
        
    }
    
==============================================================

<h3>递归实现 deleteMin，如果b.left=a，要删除a，必须设置b.left！=a，例如b.left=None，直接设置a=None没有用，因为这样只是将a的指针指向
None，b.left依旧是指向原来的a。这里return x.right，是因为后面的delete方法删除节点后需要其子节点填补，所以取对边的子节点</h3>

    private Node deleteMin(Node x) {     
        if(x.left == null)
            return x.right;       
        x.left = deleteMin(x.left);
        x.size = size(x.left) + size(x.right) + 1;        
        return x;
    }
    
<h3>非递归实现 deleteMin</h3>

     private Node deleteMin(Node x) {//x must not be null        
        if(x.left == null) {
            return x.right;
        }        
        Node cur = x;
        Node parent = null;
        while(cur.left != null) {
            cur.size--;
            parent = cur;
            cur = cur.left;
        }
        parent.left = cur.right;       
        return x;        
    }
    
==============================================================

