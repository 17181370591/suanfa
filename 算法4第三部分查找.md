<h3>使用二分法查找的rank的源码？</h3>

    import random,numpy as np,time,pandas as pd

    def rank(keys,k):       # 返回keys里小于k的值的个数。如果k也在keys里，则k=kyes[rank(keys,k)]
        print(keys)
        a,z=0,len(keys)-1
        x,y=a,z                
        while x<=y:
            m=int(x/2+y/2)
            #print(x,y,m)
            if keys[m]<k:
                x+=1
            elif keys[m]>k:
                y-=1
            else:
                return m
        return x

    a,b,k=1000,10,400
    keys=np.random.randint(a,size=(1,b))[0]
    keys.sort()
    print(rank(keys,k))

==============================================================

<h3>递归实现 get</h3>

    private Value get(Node x, Key key) {
        
        if(x == null)
            return null;//serach miss
        
        int cmp = key.compareTo(x.key);
        
        if(cmp < 0)
            return get(x.left, key);
        else if(cmp > 0)
            return get(x.right, key);
        else
            return x.val;//serach hit   
    }
    
<h3>非递归实现 get</h3>

    public Value get(Key key) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        Node cur = root;
        while(cur != null) {
            int cmp = key.compareTo(cur.key);
            if(cmp < 0)
                cur = cur.left;
            else if(cmp > 0)
                cur = cur.right;
            else
                return cur.val;//search hit
        }        
        return null;//search miss       
    }
    
==============================================================

<h3>递归实现 put。因为插入节点会更新二叉树信息（新建节点的父节点要更新size和left/right，后面的父节点要更新size），所以需要return节点，与其父节点更新信息。</h3>

    private Node put(Node x, Key key, Value val) {
        
        if(x == null) 
            return new Node(key, val, 1);
        
        int cmp = key.compareTo(x.key);
        
        if(cmp < 0)
            x.left = put(x.left, key, val);
        else if(cmp > 0) 
            x.right = put(x.right, key, val);
        else
            x.val = val;       
        x.size = size(x.left) + size(x.right) + 1;       
        return x;     
    }
    
<h3>非递归实现 get</h3>
    
    public void put(Key key, Value val) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        if(val == null) {
            delete(key);
            return;
        }
        
        if(root == null) {
            root = new Node(key, val);
            return;
        }
        
        boolean alreadyin = contains(key);//see if it needs to update the counts
        Node parent = null;
        Node cur = root;
        
        while(cur != null) {
            parent = cur;
            cur.size = alreadyin ? cur.size : cur.size + 1;//change size of cur
            
            int cmp = key.compareTo(cur.key);
            if(cmp < 0)
                cur = cur.left;
            else if(cmp > 0)
                cur = cur.right;
            else {
                cur.val = val;
                return;
            }
        }
        
        if(key.compareTo(parent.key) < 0)
            parent.left = new Node(key, val);
        else
            parent.right = new Node(key, val);       
    }
    
==============================================================

<h3>递归实现 floor。 x.left.right!=x，而且一个元素右边的值都大于其左边的值，哪怕不是其子元素。
x.key==k到就返回x，小于就向右即x=x.right，否则就向左。但是有可能找不到，所以不能三种情况都直接return，
这里选择了右移处理找不到的情况，因为用左移动处理需要-1，即从k的右边穿越到k的左边</h3>

    private Node floor(Node x, Key key) {
        
        if(x == null)
            return null;
        
        int cmp = key.compareTo(x.key);
        
        if(cmp == 0)
            return x;
        if(cmp < 0)
            return floor(x.left, key);//in left subtree
        
        Node t = floor(x.right, key);//see if right subtree has a key is the floor(key)
        if(t != null)
            return t;//yes, return t
        else
            return x;//no, return x
            }
            

<h3>非递归实现 floor</h3>

     public Key floor(Key key) {
        
        if(key == null)
            throw new IllegalArgumentException("key is null");
        
        Node cur = root;
        Key result = null;
        
        while(cur != null) {//it works when BST is empty
            int cmp = key.compareTo(cur.key);
            
            if(cmp < 0) {
                cur = cur.left;
            }
            else if(cmp > 0) {
                result = cur.key;//may be updated
                cur = cur.right;//see if the right subtree has a key smaller than or equal to key
            }
            else {
                return cur.key;//final result
            }
        }
        return result;        
    }

==============================================================

