#扑克牌排序

    import random,numpy as np,time
    l=np.arange(52)+1
    np.random.shuffle(l)
    print(l)

    def ex(l,a,b):        #交换两张牌
        l[a],l[b]=l[b],l[a]

    def f(l):             #希尔排序换牌
        h,le=1,len(l)
        while h<le/3:
            h=h*3+1
        print(h)
        while h>0:
            for i in range(h,le):
                for j in range(i,h-1,-h):
                    if l[j]<l[j-h]:
                        l[j],l[j-h]=l[j-h],l[j]
            h=int(h/3)
        print(l)

================================================================

#把箱装货物按日期排序，尽量少移动多查找，只有一个空箱子

    def zzz(a1,a2):
        dic,re,t=dict(zip(a2,a1)),[],''    #获取移动前{货物：位置}的字典，re用来插入货物移动顺序，t表示空箱子放什么
        for i in range(len(a2)):      #遍历货物
            if a1[i]!=a2[i]:            
                p=a2[i]                #p表示 当前需要移动的货物
                while p not in re:          #p如果不在re，说明从未被移动过，进入循环
                    re.append(p)            
                    #移动p 
                    if not t:           # 如果t为空，说明下一个货物先移动到空箱子
                        t=p
                    elif dic[p] in re:         #如果t不为空，且应该被移动的箱子是a2[i]（这个箱子在空箱子位置），则清空t并在一次移动a2[i]
                        t=''
                        re.append(a2[i])
                    p=dic[p]              #处理p被移动后空缺位置
        print('re:',re)

==============================================================

#原地归并排序

    import random,numpy as np,time

    def f(l):           #创建一个l的copy，修改l，所以不return
        a,z=0,len(l)-1
        b=int(a/2+z/2)      #将l截成两段
        x=0
        y=b+1
        ll=l.copy()
        for i in range(z+1):    
            if x>b:         #左段用完了就全部从右段取值
                l[i]=ll[y]
                y+=1
            elif y>z:            #右段用完了就全部从左段取值
                l[i]=ll[x]
                x+=1           
            elif ll[x]>ll[y]:       #左段小就从左段取值
                l[i]=ll[y]
                y+=1
            elif ll[x]<=ll[y]:      #右段小就从右段取值
                l[i]=ll[x]
                x+=1

    def g(l):     
    #在不保证l中值两边增序的情况下，f只能接受长度2的数组（否则不能保证合并后是增序），所以用g切割数组，一直切割到长度为2时开始运行f
        if len(l)>1:       
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            g(l[:b])            #长度为2时可以进入while，此时运行f。这是g运行后长度为1，无法在进入循环所以不会运行f
            g(l[b:])
            f(l)        #f必须放在后面，才能保证大合并放在校合并后执行

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    g(l)
    print(l)

==============================================================
#非原地归并排序

    import random,numpy as np,time

    def f(l1,l2):           #将两个增序数组按增序合并
        #print(l1,l2)
        l3,i,j,le1,le2=[],0,0,len(l1),len(l2)
        while i<le1 and  j<le2:     #从l1和l2一一取小，取完其中一个为止
            if l1[i]<l2[j]:
                l3.append(l1[i])
                i+=1
            else:
                l3.append(l2[j])
                j+=1
        while i<le1:                #把没取完的值取完
            l3.append(l1[i])
            i+=1
        while j<le2:
            l3.append(l2[j])
            j+=1
        return l3


    def g(l):
        if len(l)>1:            #l长度为1时才可以使用f合并，所以大于1需要截断
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            #print('here',l[:b],l[:b])
            return f(g(l[:b]),g(l[b:]))
        return l

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    print(g(l))

==============================================================

#原地归并排序2

import random,numpy as np,time

def f(l):       #前面的写法是直接修改原数组，这个是两个函数都返回一个新数组，其实和非原地修改一样，不如上面的代码易理解
    a,z=0,len(l)-1
    b=int(a/2+z/2)
    x,y=0,b+1
    ll=l.copy()
    for i in range(z+1):
        if x>b:
            ll[i]=l[y]
            y+=1
        elif y>z:
            ll[i]=l[x]
            x+=1           
        elif l[x]>l[y]:
            ll[i]=l[y]
            y+=1
        elif l[x]<=l[y]:
            ll[i]=l[x]
            x+=1
    return ll
        
def g(l):
    if len(l)>1:
        a,z=0,len(l)-1
        b=int(a/2+z/2)+1
        return f(g(l[:b])+g(l[b:]))
    return l

l=np.arange(99)
np.random.shuffle(l)
l=list(l)
print(l,'\n')
print('\n',g(l))

==============================================================



