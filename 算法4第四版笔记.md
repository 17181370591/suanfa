#扑克牌排序

    import random,numpy as np,time
    l=np.arange(52)+1
    np.random.shuffle(l)
    print(l)

    def ex(l,a,b):        #交换两张牌
        l[a],l[b]=l[b],l[a]

    def f(l):             #希尔排序换牌
        h,le=1,len(l)
        while h<le/3:
            h=h*3+1
        print(h)
        while h>0:
            for i in range(h,le):
                for j in range(i,h-1,-h):
                    if l[j]<l[j-h]:
                        l[j],l[j-h]=l[j-h],l[j]
            h=int(h/3)
        print(l)

================================================================

#把箱装货物按日期排序，尽量少移动多查找，只有一个空箱子

    def zzz(a1,a2):
        dic,re,t=dict(zip(a2,a1)),[],''    #获取移动前{货物：位置}的字典，re用来插入货物移动顺序，t表示空箱子放什么
        for i in range(len(a2)):      #遍历货物
            if a1[i]!=a2[i]:            
                p=a2[i]                #p表示 当前需要移动的货物
                while p not in re:          #p如果不在re，说明从未被移动过，进入循环
                    re.append(p)            
                    #移动p 
                    if not t:           # 如果t为空，说明下一个货物先移动到空箱子
                        t=p
                    elif dic[p] in re:         #如果t不为空，且应该被移动的箱子是a2[i]（这个箱子在空箱子位置），则清空t并在一次移动a2[i]
                        t=''
                        re.append(a2[i])
                    p=dic[p]              #处理p被移动后空缺位置
        print('re:',re)

==============================================================

#原地归并排序

    import random,numpy as np,time

    def f(l):           #创建一个l的copy，修改l，所以不return
        a,z=0,len(l)-1
        b=int(a/2+z/2)      #将l截成两段
        x=0
        y=b+1
        ll=l.copy()
        for i in range(z+1):    
            if x>b:         #左段用完了就全部从右段取值
                l[i]=ll[y]
                y+=1
            elif y>z:            #右段用完了就全部从左段取值
                l[i]=ll[x]
                x+=1           
            elif ll[x]>ll[y]:       #左段小就从左段取值
                l[i]=ll[y]
                y+=1
            elif ll[x]<=ll[y]:      #右段小就从右段取值
                l[i]=ll[x]
                x+=1

    def g(l):               #将l截成两段
        if len(l)>1:        #l大于等于3时不能保证f（l）后l是增序的，所以最长为2，最后f（l）进行排序，长度大于2时拆成2段
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            g(l[:b])        
            g(l[b:])
            f(l)        

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    g(l)
    print(l)

============================================================================================

#非原地归并排序

    import random,numpy as np,time

    def f(l1,l2):           #将两个增序数组按增序合并
        #print(l1,l2)
        l3,i,j,le1,le2=[],0,0,len(l1),len(l2)
        while i<le1 and  j<le2:     #从l1和l2一一取小，取完其中一个为止
            if l1[i]<l2[j]:
                l3.append(l1[i])
                i+=1
            else:
                l3.append(l2[j])
                j+=1
        while i<le1:                #把没取完的值取完
            l3.append(l1[i])
            i+=1
        while j<le2:
            l3.append(l2[j])
            j+=1
        return l3


    def g(l):
        if len(l)>1:            #l长度为1时才可以使用f合并，所以大于1需要截断
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            #print('here',l[:b],l[:b])
            return f(g(l[:b]),g(l[b:]))
        return l

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    print(g(l))

============================================================================================

