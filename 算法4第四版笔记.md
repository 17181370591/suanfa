

#插入排序

     def p(ll):             #带return的插入排序
         a,z=0,len(ll)-1
         l=ll.copy()              #为了有返回值，重新创建数组
         for i in range(1,z+1):  
             t,j=l[i],i          #i和l[i]都会变，所以不能写t=i 
             while t<l[j-1] and j>0:     #只要最初的t小于它的前项，都将前项向后移动一个位置。保证i左边是升序
                 l[j]=l[j-1]
                 j-=1
             l[j]=t                  #向右边移动完成后，给t赋原来的值
         return l

     def p(l):                  #不带return的插入排序
        a,z=0,len(l)-1
        for i in range(1,z+1):  
            t,j=l[i],i         
            while t<l[j-1] and j>0:     
                l[j]=l[j-1]
                j-=1
            l[j]=t            
    
==============================================================
    
#扑克牌排序

     import random,numpy as np,time
     l=np.arange(52)+1
     np.random.shuffle(l)
     print(l)
     def ex(l,a,b):        #交换两张牌，它们在l的index是a，b
             l[a],l[b]=l[b],l[a]

     def f(l):             #用希尔排序换牌
         #希尔排序是每隔h个单位将原数组分成h组，每一组单独使用插入排序，然后不断缩小h直至h=1
         #用插入排序是因为多次排序后数组是有序的，插入排序比交换排序更快
             h,le=1,len(l)
             while h<le/3:
                 h=h*3+1
             print(h)
             while h>0:
                 for i in range(h,le):
                     for j in range(i,h-1,-h):
                         if l[j]<l[j-h]:
                             l[j],l[j-h]=l[j-h],l[j]
                 h=int(h/3)
             print(l)

================================================================

#把箱装货物按日期排序，尽量少移动多查找，只有一个空箱子

    def zzz(a1,a2):
        dic,re,t=dict(zip(a2,a1)),[],''    #获取移动前{货物：位置}的字典，re用来插入货物移动顺序，t表示空箱子放什么
        for i in range(len(a2)):      #遍历货物
            if a1[i]!=a2[i]:            
                p=a2[i]                #p表示 当前需要移动的货物
                while p not in re:          #p如果不在re，说明从未被移动过，进入循环
                    re.append(p)            
                    #移动p 
                    if not t:           # 如果t为空，说明下一个货物先移动到空箱子
                        t=p
                    elif dic[p] in re:  
                    #如果t不为空，且应该被移动的箱子是a2[i]（这个箱子在空箱子位置），则清空t并在一次移动a2[i]
                        t=''
                        re.append(a2[i])
                    p=dic[p]              #处理p被移动后空缺位置
        print('re:',re)

==============================================================

这段代码有问题这段代码有问题这段代码有问题这段代码有问题这段代码有问题这段代码有问题
#原地归并排序！这段代码有问题，到为什么g(N)里g(N/2)，g(N/2)后l不会更新，f(N)还使用最初的l

    import random,numpy as np,time

    def f(l):           #创建一个l的copy，修改l，所以不return
        a,z=0,len(l)-1
        b=int(a/2+z/2)      #将l截成两段
        x=0
        y=b+1
        ll=l.copy()
        for i in range(z+1):    
            if x>b:         #左段用完了就全部从右段取值
                l[i]=ll[y]
                y+=1
            elif y>z:            #右段用完了就全部从左段取值
                l[i]=ll[x]
                x+=1           
            elif ll[x]>ll[y]:       #左段小就从左段取值
                l[i]=ll[y]
                y+=1
            elif ll[x]<=ll[y]:      #右段小就从右段取值
                l[i]=ll[x]
                x+=1

    def g(l):     
        #在不保证l中值两边增序的情况下，f只能接受长度2的数组（否则不能保证合并后是增序），
        所以用g切割数组，一直切割到长度为2时开始运行f
        if len(l)>1:       
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            g(l[:b])            #长度为2时可以进入while，此时运行f。这是g运行后长度为1，无法在进入循环所以不会运行f
            g(l[b:])
            f(l)        #f必须放在后面，才能保证大合并放在校合并后执行！这里有问题

        l=np.arange(99)
        np.random.shuffle(l)
        print(l)
        g(l)
        print(l)

==============================================================

#非原地归并排序

    import random,numpy as np,time

    def f(l1,l2):           #将两个增序数组按增序合并
        #print(l1,l2)
        l3,i,j,le1,le2=[],0,0,len(l1),len(l2)
        while i<le1 and  j<le2:     #从l1和l2一一取小，取完其中一个为止
            if l1[i]<l2[j]:
                l3.append(l1[i])
                i+=1
            else:
                l3.append(l2[j])
                j+=1
        while i<le1:                #把没取完的值取完
            l3.append(l1[i])
            i+=1
        while j<le2:
            l3.append(l2[j])
            j+=1
        return l3

     def g(l):                 #将数组大致等分分成两个数组，直到能够调用f（需要l的长度<=2）
          if len(l)>1:            #l长度为1时才可以使用f合并，所以大于1需要截断
               a,z=0,len(l)-1
               b=int(a/2+z/2)+1
               #print('here',l[:b],l[:b])
               return f(g(l[:b]),g(l[b:]))
          return l

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    print(g(l))

==============================================================

#原地归并排序2

         import random,numpy as np,time

         def f(l):           #原地归并排序
         #前面的写法是直接修改原数组，这个是两个函数都返回一个新数组，其实和非原地修改一样，不如上面的代码易理解
             a,z=0,len(l)-1
             b=int(a/2+z/2)
             x,y=0,b+1
             ll=l.copy()
             for i in range(z+1):
                 if x>b:
                     ll[i]=l[y]
                     y+=1
                 elif y>z:
                     ll[i]=l[x]
                     x+=1           
                 elif l[x]>l[y]:
                     ll[i]=l[y]
                     y+=1
                 elif l[x]<=l[y]:
                     ll[i]=l[x]
                     x+=1
             return ll

         def g(l):       #原地归并排序需要数组长度为2（或者两边的数组为升序），拆开数组调用f
             if len(l)>1:
                 a,z=0,len(l)-1
                 b=int(a/2+z/2)+1
                 return f(g(l[:b])+g(l[b:]))
             return l

         def g1(l):       
         #原地归并需要两边的数组为升序，当数组长度较短时用插入排序比归并更快，所以长度较短时用p（插入排序）
         if len(l)>300:
             a,z=0,len(l)-1
             b=int(a/2+z/2)+1
             return f(g(l[:b])+g(l[b:]))
         p(l)
         return l

         def p(l):     #插入排序
             a,z=0,len(l)-1
             for i in range(1,z+1):
                 t,j=l[i],i        
                 while t<l[j-1] and j>0:
                     l[j]=l[j-1]
                     j-=1
                 l[j]=t

         l=np.arange(99)
         np.random.shuffle(l)
         l=list(l)
         print(l,'\n')
         print('\n',g(l))


==============================================================

#快速排序，非原地，速度很快

	import random,numpy as np,time

	def g(l):           #带返回值的快速排序
			if len(l)<2:         #长度大于1时才能调用f
					return l
			ll,j=f(l)
			return g(ll[:j])+[ll[j]]+g(ll[j+1:])

	def f(ll):               #将ll的第一项作为 目标 ，和它应该在的位置的值交换
			l=ll.copy()
			#if len(l)<2:        #上面申明了长度大于1才能调用，这里暂时注释，不然不能注释
			 #   return 
			a,b=1,len(l)-1
			j,p=a-1,l[a-1]       
			while True:               
			#这里不能写while a>=b同时取消下面的  if a>=b:break，因为会出现a<b进入循环，内部循坏跳出后a>b，这时不能运行ex(l,a,b)
					while l[a]<l[j] and a<len(l)-1:      
					#从左往右遍历，遇到不小于 目标 的项i跳出循环；a最大取len-1，跳出后为len，不然重新进入循环可能出现out of index
							a+=1
					while l[b]>l[j] and b>0:
					#从右往左遍历，遇到不大于 目标 的项i跳出循环；a最小取1，跳出后为0，不然重新进入循环可能出现意外状况 
							b-=1
					if a>=b:        #跳出内部循环后，如果a<b说明已经替换完成，不用再替换
							break
					ex(l,a,b)
			ex(l,b,j)            #将 目标 与正确的位置的值交换
			return l,l.index(p)            #不带返回值总是出现list不跟新的bug，不知道怎么处理

	def ex(l,a,b):           #交换
			l[a],l[b]=l[b],l[a]


	l=np.arange(100000)
	np.random.shuffle(l)
	l=list(l)
	print(type(l),l[:11],'\n')
	t1=time.clock()
	gg=g(l)
	print('\n',gg[:11],time.clock()-t1)

==============================================================


