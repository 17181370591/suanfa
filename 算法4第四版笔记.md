

#插入排序。数据少时速度很快，8~15？

     def p(ll):             #带return的插入排序
         a,z=0,len(ll)-1
         l=ll.copy()              #为了有返回值，重新创建数组
         for i in range(1,z+1):  
             t,j=l[i],i          #i和l[i]都会变，所以不能写t=i 
             while t<l[j-1] and j>0:     #只要最初的t小于它的前项，都将前项向后移动一个位置。保证i左边是升序
                 l[j]=l[j-1]
                 j-=1
             l[j]=t                  #向右边移动完成后，给t赋原来的值
         return l

     def p(l):                  #不带return的插入排序
        a,z=0,len(l)-1
        for i in range(1,z+1):  
            t,j=l[i],i         
            while t<l[j-1] and j>0:     
                l[j]=l[j-1]
                j-=1
            l[j]=t            
    
==============================================================
    
#扑克牌排序 

     import random,numpy as np,time
     l=np.arange(52)+1
     np.random.shuffle(l)
     print(l)
     def ex(l,a,b):        #交换两张牌，它们在l的index是a，b
             l[a],l[b]=l[b],l[a]

     def f(l):             #用希尔排序换牌
         #希尔排序是每隔h个单位将原数组分成h组，每一组单独使用插入排序，然后不断缩小h直至h=1
         #用插入排序是因为多次排序后数组是有序的，插入排序比交换排序更快
             h,le=1,len(l)
             while h<le/3:
                 h=h*3+1
             print(h)
             while h>0:
                 for i in range(h,le):
                     for j in range(i,h-1,-h):
                         if l[j]<l[j-h]:
                             l[j],l[j-h]=l[j-h],l[j]
                 h=int(h/3)
             print(l)

================================================================

#把箱装货物按日期排序，尽量少移动多查找，只有一个空箱子

    def zzz(a1,a2):
        dic,re,t=dict(zip(a2,a1)),[],''    #获取移动前{货物：位置}的字典，re用来插入货物移动顺序，t表示空箱子放什么
        for i in range(len(a2)):      #遍历货物
            if a1[i]!=a2[i]:            
                p=a2[i]                #p表示 当前需要移动的货物
                while p not in re:          #p如果不在re，说明从未被移动过，进入循环
                    re.append(p)            
                    #移动p 
                    if not t:           # 如果t为空，说明下一个货物先移动到空箱子
                        t=p
                    elif dic[p] in re:  
                    #如果t不为空，且应该被移动的箱子是a2[i]（这个箱子在空箱子位置），则清空t并在一次移动a2[i]
                        t=''
                        re.append(a2[i])
                    p=dic[p]              #处理p被移动后空缺位置
        print('re:',re)

==============================================================

这段代码有问题。原因是g(l[:b])；g(l[b:])；f(l)这里，因为传入的参数l（列表）的切片，切片被修改后l本身是不变的
如果l是numpy或者pandas类型数据就没问题，因为切片被修改l本身也会改变
#原地归并排序！这段代码有问题，到为什么g(N)里g(N/2)，g(N/2)后l不会更新，f(N)还使用最初的l

    import random,numpy as np,time

    def f(l):           #创建一个l的copy，修改l，所以不return
        a,z=0,len(l)-1
        b=int(a/2+z/2)      #将l截成两段
        x=0
        y=b+1
        ll=l.copy()
        for i in range(z+1):    
            if x>b:         #左段用完了就全部从右段取值
                l[i]=ll[y]
                y+=1
            elif y>z:            #右段用完了就全部从左段取值
                l[i]=ll[x]
                x+=1           
            elif ll[x]>ll[y]:       #左段小就从左段取值
                l[i]=ll[y]
                y+=1
            elif ll[x]<=ll[y]:      #右段小就从右段取值
                l[i]=ll[x]
                x+=1

    def g(l):     
        #在不保证l中值两边增序的情况下，f只能接受长度2的数组（否则不能保证合并后是增序），
        所以用g切割数组，一直切割到长度为2时开始运行f
        if len(l)>1:       
            a,z=0,len(l)-1
            b=int(a/2+z/2)+1
            g(l[:b])            #长度为2时可以进入while，此时运行f。这是g运行后长度为1，无法在进入循环所以不会运行f
            g(l[b:])
            f(l)        #f必须放在后面，才能保证大合并放在校合并后执行！这里有问题

        l=np.arange(99)
        np.random.shuffle(l)
        print(l)
        g(l)
        print(l)

==============================================================

#非原地归并排序

    import random,numpy as np,time

    def f(l1,l2):           #将两个增序数组按增序合并
        #print(l1,l2)
        l3,i,j,le1,le2=[],0,0,len(l1),len(l2)
        while i<le1 and  j<le2:     #从l1和l2一一取小，取完其中一个为止
            if l1[i]<l2[j]:
                l3.append(l1[i])
                i+=1
            else:
                l3.append(l2[j])
                j+=1
        while i<le1:                #把没取完的值取完
            l3.append(l1[i])
            i+=1
        while j<le2:
            l3.append(l2[j])
            j+=1
        return l3

     def g(l):                 #将数组大致等分分成两个数组，直到能够调用f（需要l的长度<=2）
          if len(l)>1:            #l长度为1时才可以使用f合并，所以大于1需要截断
               a,z=0,len(l)-1
               b=int(a/2+z/2)+1
               #print('here',l[:b],l[:b])
               return f(g(l[:b]),g(l[b:]))
          return l

    l=np.arange(99)
    np.random.shuffle(l)
    print(l)
    print(g(l))

==============================================================

#原地归并排序2

         import random,numpy as np,time

         def f(l):           #原地归并排序
         #前面的写法是直接修改原数组，这个是两个函数都返回一个新数组，其实和非原地修改一样，不如上面的代码易理解
             a,z=0,len(l)-1
             b=int(a/2+z/2)
             x,y=0,b+1
             ll=l.copy()
             for i in range(z+1):
                 if x>b:
                     ll[i]=l[y]
                     y+=1
                 elif y>z:
                     ll[i]=l[x]
                     x+=1           
                 elif l[x]>l[y]:
                     ll[i]=l[y]
                     y+=1
                 elif l[x]<=l[y]:
                     ll[i]=l[x]
                     x+=1
             return ll

         def g(l):       #原地归并排序需要数组长度为2（或者两边的数组为升序），拆开数组调用f
             if len(l)>1:
                 a,z=0,len(l)-1
                 b=int(a/2+z/2)+1
                 return f(g(l[:b])+g(l[b:]))
             return l

         def g1(l):       
            #原地归并需要两边的数组为升序，当数组长度较短时用插入排序比归并更快，所以长度较短时用p（插入排序），比g快不少
             if len(l)>30:
                 a,z=0,len(l)-1
                 b=int(a/2+z/2)+1
                 return f(g1(l[:b])+g1(l[b:]))
             p(l)
             return l

         def p(l):     #插入排序
             a,z=0,len(l)-1
             for i in range(1,z+1):
                 t,j=l[i],i        
                 while t<l[j-1] and j>0:
                     l[j]=l[j-1]
                     j-=1
                 l[j]=t

         l=np.arange(99)
         np.random.shuffle(l)
         l=list(l)
         print(l,'\n')
         print('\n',g(l))


==============================================================

#快速排序，非原地，速度很快

    import random,numpy as np,time

	def g(l):           #带返回值的快速排序
	    if len(l)<2:         #长度大于1时才能调用f
		    return l
		ll,j=f(l)
		return g(ll[:j])+[ll[j]]+g(ll[j+1:])

	def f(ll):               #将ll的第一项作为 目标 ，和它应该在的位置的值交换
		l=ll.copy()
		#if len(l)<2:        #上面申明了长度大于1才能调用，这里暂时注释，不然不能注释
		#   return 
		a,b=1,len(l)-1 
		j,p=a-1,l[a-1]       
		while True:               
		#这里不能写while a>=b同时取消下面的  if a>=b:break，因为会出现a<b进入循环，
		 #内部循坏跳出后a>b，这时不能运行ex(l,a,b)
		    while l[a]<=l[j] and a<len(l)-1:      
			#从左往右遍历，遇到不小于 目标 的项i跳出循环；a最大取len-1，跳出后为len，
			 #不然重新进入循环可能出现out of index
			 #写=是为了处理相同的，不写的话会卡死，下同
				a+=1
			while l[b]>=l[j] and b>0:
			#从右往左遍历，遇到不大于 目标 的项i跳出循环；a最小取1，跳出后为0，
			 #不然重新进入循环可能出现意外状况 
				b-=1
			if a>=b:        #跳出内部循环后，如果a<b说明已经替换完成，不用再替换
				break
			ex(l,a,b)
		ex(l,b,j)            #将 目标 与正确的位置的值交换
		return l,l.index(p)            #不带返回值总是出现list不跟新的bug，不知道怎么处理

	def ex(l,a,b):           #交换
		l[a],l[b]=l[b],l[a]


	l=np.arange(100000)
	np.random.shuffle(l)
	l=list(l)
	print(type(l),l[:11],'\n')
	t1=time.clock()
	gg=g(l)
	print('\n',gg[:11],time.clock()-t1)

==============================================================

#三向切分
a和z表示数组两端的index ， v表示哨兵的值 ， x和y表示等于v的数组的两端的index 

	import random,numpy as np,time,pandas as pd

	def so(l):          #测试整个数组是否有序
	    for i in range(1,len(l)):
		if l[i]<l[i-1]:
		    return False
	    return True

	def f(ll):         # 带返回值的三向切分的递归部分
	    if len(ll)<2:
		return ll
	    l,a,b=g(ll)
	    return f(l[:a])+l[a:b+1]+f(l[b+1:])

	def g(ll):          #带返回值的三向切分
	    if len(ll)<2:
		return ll
	    l=ll.copy()
	    a,z=0,len(l)-1
	    x,y,v,i=a,z,l[a],a+1
	    while i<=y:       
		if l[i]<v:
		    ex(l,x,i)
		    i+=1
		    x+=1
		elif l[i]>v:
		    ex(l,y,i)
		    y-=1
		else:
		    i+=1
	    return l,x,y

	def g1(l,a,z):      #不带返回值的三向切分
	    if len(l)<2 or a>z:
		return 
	    x,y,v,i=a,z,l[a],a+1
	    #print(x,y,v,i,l,a,z)
	    while i<=y:       		
		if l[i]<v:		 
		#如果i的值小于v，交换i和x，x和i都加1，即i开始下轮，x作为v数组（中间的值都等于v的部分）的左端向右移动一个位置
		    ex(l,x,i)
		    i+=1
		    x+=1
		elif l[i]>v:
		#如果i的值大于v，交换i和y，y减1，y作为v数组的右端向左移动一个位置，i不变是因为i的值被更新需要重新比较
		    ex(l,y,i)
		    y-=1
		else:
		 #如果i的值等于v，则不进行交换，只让i进入下一次循环。因为v数组的左右都不需要变动
		    i+=1
	    g1(l,a,x-1)
	    g1(l,y+1,z)

	def ex(l,a,b):          #交换两项
	    l[a],l[b]=l[b],l[a]

 
	l=np.arange(200000)
	p1=pd.Series(l/3).map(round)
	np.random.shuffle(p1)
	p1=list(p1)
	p2=p1.copy()
	print(type(p1),p1[:30],'\n')

	t1=time.clock()
	gg=f(p1)
	print('\n',time.clock()-t1)
	t1=time.clock()
	print(so(gg),time.clock()-t1)

	t1=time.clock()
	g1(p2,0,len(p2)-1)
	print(time.clock()-t1)

	t1=time.clock()
	print(so(p2),time.clock()-t1)


==============================================================


