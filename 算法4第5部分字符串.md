
<h3>低位优先的字符串排序。count数组是里count(x)用来统计前x-1组的长度和，所以第一个循环a[i].charAt(d) + 1，
因为count(0)前面没有组，应该等于0。大循环内部第一个循环完成后，count里count(x)表示第x-1组的长度，
第二个循环后count(x)是前x-1组的长度和，第三个循环将a[i]加入aux，在aux的位置是a[i]在所有key=i里的位置+count(i)。
大循环是将等长的字符串从后向前遍历，这样能保证所有的字符串按从前到后排序（两个字符串比较时比完第一个比第二个，以此类推）</h3>

        public class LSD {
                public static void sort(String[] a, int W) {   
                        int N = a.length;
                        int R = 256;
                        String[] aux = new String[N];

                        for (int d = W - 1; d >= 0; d--) {
                                int[] count = new int[R + 1];
                                for (int i = 0; i < N; i++) {
                                        count[a[i].charAt(d) + 1]++;
                                }

                                for (int r = 0; r < R; r++) {
                                        count[r + 1] += count[r];
                                }

                                for (int i = 0; i < N; i++) {
                                        aux[count[a[i].charAt(d)]++] = a[i];
                                }

                                for (int i = 0; i < N; i++) {
                                        a[i] = aux[i];
                                }
                        }
                }
                
========================================================================

<h3>上面的python代码</h3>

        import random,numpy as np
        r={}                    #r是字符串0-9a-z指向0-36的字典
        for i in range(10):
            r[str(i)]=i
        for i in range(97,97+26):
            r[chr(i)]=i-87
        d=np.random.choice(list(r.keys()),size=(33,3)).tolist()
        d=list(map(''.join,d))

        def sor1(d,w):
            for  x in range(w,-1,-1):
                le=len(d)
                l=[0]*(len(r)+1)
                for i in d:
                    l[r[i[x]]+1]+=1
                    
                for i in range(len(l)-1):
                    l[i+1]+=l[i]
                    
                dd=list(range(le))
                
                for i in d:
                    dd[l[r[i[x]]]]=i
                    l[r[i[x]]]+=1
                print('第{}次遍历后：{}'.format(w-x+1,dd))
                d=dd

        sor1(d,len(d[0])-1)

========================================================================

<h3>高位排序。R是字母种类的个数，M是小数组的切换阈值（即数组长度<=M时调用Insertion.sort(a, lo, hi, d)并不再递归），charat用来在s里查找第d个字符串，找不到则返回-1，思路是：
count数组长度是r+2，因为需要额外一个项来保存charAt返回-1的字符串个数。举例说明，count用来记录a到d4个字母的数量，则count的长度是6，charAt是{a:0,b:1,c:2,d:3，None:-1}，所以循环a1完成后count=[0，numNone，numa,numb,numc,numd]，循环a2完成后count=[0，numNone，numa+numNone,numb+numa+numNone,numc+numb+numa+numNone,numd+numc+numb+numa+numNone（这一项也等于hi-lo+1，即数组被遍历部分的长度）]，循环a3是将a排序到aux，完成后后count=[numNone，numa+numNone,numb+numa+numNone,numc+numb+numa+numNone,hi-lo+1，hi-lo+1]，循环a4是将aux按顺序复制回a，此时a已经被排序，此时count的各个值正是a被分成各个值对应的块的起点和终点-1，例如最开始是None部分，个数等于numNone，，所以最后一个None是numNone-1，正好等于count（0）-1，第二部分是a开头的部分，第一个是numNone（正好等于count（0）），个数是numa，所以最后一个是numNone+numa-1，正好等于count（1）-1，循环a5是将a的这些块递归排序，所以写成sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1）。对于相同的字符串速度很慢，因为这些项会一直在同一个数组里被复制粘贴，不被修改，知道寻找超过它们长度的字符时被移到count（0）区域被删除</h3>

        public class MSD {
                private static int R = 256;
                private static final int M = 15;
                private static String[] aux;

                private static int charAt(String s, int d) {
                        if (d < s.length()) {
                                return s.charAt(d);
                        } else {
                                return -1;
                        }
                }

                public static void sort(String[] a) {
                        int N = a.length;
                        aux = new String[N];
                        sort(a, 0, N - 1, 0);
                }

                private static void sort(String[] a, int lo, int hi, int d) {
                        // 以第d个字符为键将a[lo]至a[hi]排序
                        if (hi <= lo + M) {
                                Insertion.sort(a, lo, hi, d);
                                return;
                        }
                        int[] count = new int[R + 2];
                        for (int i = lo; i <= hi; i++) {                #循环a1
                                count[charAt(a[i], d) + 2]++;
                        }

                        for (int r = 0; r < R + 1; r++) {                 #循环a2
                                count[r + 1] += count[r];
                        }

                        for (int i = lo; i <= hi; i++) {                 #循环a3
                                aux[count[charAt(a[i], d) + 1]++] = a[i];
                        }

                        for (int i = lo; i <= hi; i++) {                 #循环a4
                                a[i] = aux[i - lo];
                        }

                        for (int r = 0; r < R; r++) {                    #循环a5
                                sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1);
                        }
                }
        }
        
<h4>小数组调用的 Insertion.sort()，思路就是第二章的交换排序，compareTo会从左向右比较每个字符</h4>

        public class Insertion {
                public static void sort(String[] a, int lo, int hi, int d) {
                        // 从第d个字符开始对a[lo]到a[hi]排序
                        for (int i = lo; i <= hi; i++) {
                                for (int j = i; j > lo && less(a[j], a[j - 1], d); j--) {
                                        exch(a, j, j - 1);
                                }
                        }
                }

                private static boolean less(String v, String w, int d) {
                        return v.substring(d).compareTo(w.substring(d)) < 0;
                }

                private static void exch(String[] a, int i, int j) {
                        String temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                }
        }

========================================================================

<h3>上面的python代码</h3>

        import random,time
        
        M=10
        Di={}           #用来保存字符到数字的映射
        for i in range(65,65+26):       
                Di[chr(i)]=i-65

        def cr(A,lo,hi):        #插入排序来对小数组进行排序，因为后期会生成大量的小数组造成程序变慢
            for i in range(lo+1,hi+1):
                for j in range(i,lo,-1):
                    if com(A[j],A[j-1]):
                        A[j],A[j-1]=A[j-1],A[j]
                    else:
                        break

        def com(a,b):           #比较a，b两个字符串的大小
            w=0
            l=max(len(a),len(b))
            while w<l:
                if D(a,w)>D(b,w):
                   return False
                if D(a,w)<D(b,w):
                   return True
                w+=1
            return True

        def D(s,i):             #返回字符串s的第i的字符的数字
            try:
                return Di[s[i]]
            except Exception:
                return -1

        def so(A,m,lo,hi):              #排序

            if lo+M>hi:                 #当数组长度小于M时不再递归，而是调用插入排序
                cr(A,lo,hi)
                return

            L=[0]*(2+len(Di))                   #保存A[lo,hi+1]内的字符的频率->索引->真索引信息
            for i in range(lo,hi+1):
                L[2+D(A[i],m)]+=1

            for i in range(len(L)-1):           #频率转索引
                L[i+1]+=L[i]

            for i in range(lo,hi+1):            #在B里按增序写入A，并索引转真索引
                s=D(A[i],m)+1
                B[L[s]]=A[i]
                L[s]+=1

            for i in range(lo,hi+1):            #B写回A
                A[i]=B[i-lo]

            for i in range(len(L)-1):             #L记载了A[lo,hi+1]的分段信息，但是它的索引是从0开始，所以全部+lo
                so(A,m+1,L[i]+lo,L[i+1]+lo-1)

        a,b=10**6,10                           #生成随机数据A，a是字符串总个数，b是最长长度
        A=[]
        for i in range(a):
            c=random.randint(0,b)
            s=''
            for j in range(c):
                s+=random.choice(list(Di.keys()))
            A.append(s)

        B=['']*len(A)                           #用来保存A[lo,hi+1]排序后的数组，所以写回A时要A[i]=B[i-lo]
        m=0
        t1=time.clock()
        so(A,m,0,len(A)-1)                      #测试排序花的时间，使用插入排序后时间大大幅度缩短
        print(time.clock()-t1)

        for i in range(len(A)-1):               #通过遍历，测试是否排序成功
            if not com(A[i],A[i+1]):
                print(i,'#'*22,A[i],A[i+1])
                break

        with open('1.txt','w') as f:            #保存排序后数组A，调试用
            f.write('---'.join(A).replace(' ',''))

========================================================================

<h3>三向字符串快速排序，和3切分类似。思路是：数组第一项的charAt(a[lo], d)做参照物，大于它的向右交换并移到数组[lt,gt]外，小于它的向左交换并移到数组[lt,gt]外。最终得到的数组[lt,gt]就是等于参照物的集合，对集合的下一个字符递归，同时对集合左边，右边分别递归，这样实际运行顺序会完全按照数组的顺序运行</h3>

        public class Quick3string {
                private static int charAt(String s, int d) {
                        if (d < s.length()) {
                                return s.charAt(d);
                        } else {
                                return -1;
                        }
                }

                public static void sort(String[] a) {
                        sort(a, 0, a.length - 1, 0);
                }

                private static void sort(String[] a, int lo, int hi, int d) {
                        if (hi <= lo) {
                                return;
                        }
                        int lt = lo, gt = hi;
                        int v = charAt(a[lo], d);
                        int i = lo + 1;
                        while (i <= gt) {
                                int t = charAt(a[i], d);
                                if (t < v) {
                                        exch(a, lt++, i++);
                                } else if (t > v) {
                                        exch(a, i, gt--);
                                } else {
                                        i++;
                                }
                        }
                        sort(a, lo, lt - 1, d);
                        if (v >= 0) {
                                sort(a, lt, gt, d + 1);
                        }
                        sort(a, gt + 1, hi, d);
                }

                private static void exch(String[] a, int i, int j) {
                        String temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                }
        }
        
========================================================================

<h3>基于单词查找树的符号表</h3>

        public class TrieST<Value> {
                private static int R = 256;
                private Node root;

                private static class Node {
                        private Object val;
                        private Node[] next = new Node[R];
                }

                public Value get(String key) {
                        Node x = get(root, key, 0);
                        if (x == null) {
                                return null;
                        }
                        return (Value) x.val;
                }
                       
                #d的作用是用来表示当前在查找key的第k个字符，所以d == key.length()表示找到了key最后一位
                
                private Node get(Node x, String key, int d) {
                        if (x == null) {
                                return null;
                        }
                        if (d == key.length()) {
                                return x;
                        }
                        char c = key.charAt(d);
                        return get(x.next[c], key, d + 1);
                }

                public void put(String key, Value val) {
                        root = put(root, key, val, 0);
                }

                #如果不存在x则新建节点，并让上家的next等于它（通过x.next[c] = put(x.next[c], key, val, d + 1)这句代码赋值），d == key.length()依旧表示已经找到key的最后一位
                
                private Node put(Node x, String key, Value val, int d) {
                        if (x == null) {
                                x = new Node();
                        }
                        if (d == key.length()) {
                                x.val = val;
                                return x;
                        }
                        char c = key.charAt(d);
                        x.next[c] = put(x.next[c], key, val, d + 1);
                        return x;
                }

                public int size() {
                        return size(root);
                }

               #某个节点有val表示找到一个字符串，递归的顺序和深度优先查找一样
               
               private int size(Node x) {
                        if (x == null) {
                                return 0;
                        }

                        int cnt = 0;
                        if (x.val != null) {
                                cnt++;
                        }
                        for (char c = 0; c < R; c++) {
                                cnt += size(x.next[c]);
                        }
                        return cnt;
                }

               public Iterable<String> keys() {
                        return keysWithPrefix("");
                }

               #查找以pre开头的字符串，保存到q里并返回
               
               public Iterable<String> keysWithPrefix(String pre) {
                        Queue<String> q = new Queue<String>();
                        collect(get(root, pre, 0), pre, q);
                        return q;
                }

                #第二个if表示每找到一个val就存入一个pre，每递归一次就在pre后面加入新加入的字符，这pre的作用是：因为没有函数直接返回从根节点到当前节点的所有字符，所以用pre来管理这些字符的和。显示pre需要满足条件才有效，条件就是当前x是通过pre找到（get）的，否则pre本身毫无意义
                
                private void collect(Node x, String pre, Queue<String> q) {
                        if (x == null) {
                                return;
                        }
                        if (x.val != null) {
                                q.enqueue(pre);
                        }
                        for (char c = 0; c < R; c++) {
                                collect(x.next[c], pre + c, q);
                        }
                }

                public Iterable<String> keysThatMatch(String pat) {
                        Queue<String> q = new Queue<String>();
                        collect(root, "", pat, q);
                        return q;
                }

                #带匹配的collect方法，只返回正好匹配pat的项，所以d == pat.length() && x.val != null时才加入pre。当pre的length小于pat时，由于pre会增长所以属于正常现象，如果大于，则不会触发递归然后退出函数，等于同理，pre和pat吻合时才能找到pat
                
                private void collect(Node x, String pre, String pat, Queue<String> q) {
                        int d = pre.length();
                        if (x == null) {
                                return;
                        }
                        if (d == pat.length() && x.val != null) {
                                q.enqueue(pre);
                        }
                        if (d == pat.length()) {
                                return;
                        }

                        char next = pat.charAt(d);
                        for (char c = 0; c < R; c++) {
                                if (next == '.' || next == c) {
                                        collect(x.next[c], pre + c, pat, q);
                                }
                        }
                }

                   #返回能在x里找到的s的前个字符的最大length。
                   
                public String longestPrefixOf(String s) {
                        int length = search(root, s, 0, 0);
                        return s.substring(0, length);
                }

                 #返回能在x里找到的s的前个字符的最大length。第二个if表示找打val（字符串）时，更新length；第三个if表示不需要查找s.length+1，可以直接跳出函数。
                 
                 private int search(Node x, String s, int d, int length) {
                        if (x == null) {
                                return length;
                        }
                        if (x.val != null) {
                                length = d;
                        }
                        if (d == s.length()) {
                                return length;
                        }
                        char c = s.charAt(d);
                        return search(x.next[c], s, d + 1, length);
                }
                public void delete(String key) {
                        root = delete(root, key, 0);
                }

                 #删除val。第二个if表示找到了key的最后一个字符，删除此时x的val。else表示没找到最后一个，继续找，并将递归的结果赋值给当前的。第三个if作用是遇到从后面同时删除key和val的情况，在找到某个key有val的情况下终止。for循环表示如果x有子节点，则不需要删除本身的key，否则return null表示删除本身的key。举例：（数字是前一个字符的val）a0cd1fg2删除g，删除2后发现没有子节点，所以g也变成null（删除key），同理删除f，由于d有val，所以最终剩下a0cd1。另一个例子，a0cd1fg2删除d，删除2后发现d有子节点，所以不再操作，所以得到a0cfg2
                 
                 private Node delete(Node x, String key, int d) {
                        if (x == null) {
                                return null;
                        }
                        if (d == key.length()) {
                                x.val = null;
                        } else {
                                char c = key.charAt(d);
                                x.next[c] = delete(x.next[c], key, d + 1);
                        }

                        if (x.val != null) {
                                return x;
                        }

                        for (char c = 0; c < R; c++) {
                                if (x.next[c] != null) {
                                        return x;
                                }
                        }
                        return null;
                }
        }

========================================================================

<h3>基于三向单词查找树的符号表</h3>

        public class TST<Value> {
                private Node root;

                private class Node {
                        char c;
                        Node left, mid, right;
                        Value val;
                }

                public Value get(String key) {
                        Node x = get(root, key, 0);
                        if (x == null) {
                                return null;
                        }
                        return (Value) x.val;
                }

                private Node get(Node x, String key, int d) {
                        if (x == null) {
                                return null;
                        }
                        char c = key.charAt(d);
                        if (c < x.c) {
                                return get(x.left, key, d);
                        } else if (c > x.c) {
                                return get(x.right, key, d);
                        } else if (d < key.length() - 1) {
                                return get(x.mid, key, d + 1);
                        } else {
                                return x;
                        }
                }

                public void put(String key, Value val) {
                        root = put(root, key, val, 0);
                }

                private Node put(Node x, String key, Value val, int d) {
                        char c = key.charAt(d);
                        if (x == null) {
                                x = new Node();
                                x.c = c;
                        }
                        if (c < x.c) {
                                x.left = put(x.left, key, val, d);
                        } else if (c > x.c) {
                                x.right = put(x.right, key, val, d);
                        } else if (d < key.length() - 1) {
                                x.mid = put(x.mid, key, val, d + 1);
                        } else {
                                x.val = val;
                        }
                        return x;
                }

                // Exercise 5.2.9
                public String longestPrefixOf(String s) {
                        if (s.length() == 0)
                                return null;
                        int length = 0;
                        Node x = root;
                        int i = 0;
                        while (x != null && i < s.length()) {
                                char c = s.charAt(i);
                                if (c < x.c) {
                                        x = x.left;
                                } else if (c > x.c) {
                                        x = x.right;
                                } else {
                                        i++;
                                        if (x.val != null) {
                                                length = i;
                                        }
                                        x = x.mid;
                                }
                        }
                        return s.substring(0, length);
                }

                public Iterable<String> keys() {
                        return keysWithPrefix("");
                }

                private Iterable<String> keysWithPrefix(String pre) {
                        Queue<String> q = new Queue<>();
                        collect(get(root, pre, 0).mid, pre, q);
                        return q;
                }

                private void collect(Node x, String pre, Queue<String> q) {
                        if (x == null) {
                                return;
                        }
                        if (x.val != null) {
                                q.enqueue(pre);
                        }
                        collect(x.left, pre, q);
                        collect(x.right, pre, q);
                        collect(x.mid, pre + x.c, q);
                }

                public Iterable<String> keysThatMatch(String pat) {
                        Queue<String> q = new Queue<>();
                        collect(root, "", pat, q);
                        return q;
                }

                private void collect(Node x, String pre, String pat, Queue<String> q) {
                        if (x == null) {
                                return;
                        }
                        int d = pre.length();
                        char c = pat.charAt(d);
                        if (c == '.' || c < x.c) {
                                collect(x.left, pre, pat, q);
                        }
                        if (c == '.' || c > x.c) {
                                collect(x.right, pre, pat, q);
                        }
                        if (c == '.' || c == x.c) {
                                if (d + 1 == pat.length() && x.val != null) {
                                        q.enqueue(pre + c);
                                }
                                if (d + 1 < pat.length()) {
                                        collect(x.mid, pre + c, pat, q);
                                }
                        }
                }
        }

========================================================================

kmp：next函数看懂了，kmp看不懂

========================================================================



