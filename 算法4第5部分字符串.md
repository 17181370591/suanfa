
<h3>低位优先的字符串排序。count数组是里count(x)用来统计前x-1组的长度和，所以第一个循环a[i].charAt(d) + 1，
因为count(0)前面没有组，应该等于0。大循环内部第一个循环完成后，count里count(x)表示第x-1组的长度，
第二个循环后count(x)是前x-1组的长度和，第三个循环将a[i]加入aux，在aux的位置是a[i]在所有key=i里的位置+count(i)。
大循环是将等长的字符串从后向前遍历，这样能保证所有的字符串按从前到后排序（两个字符串比较时比完第一个比第二个，以此类推）</h3>

        public class LSD {
                public static void sort(String[] a, int W) {                     
                        int N = a.length;
                        int R = 256;
                        String[] aux = new String[N];

                        for (int d = W - 1; d >= 0; d--) {
                                int[] count = new int[R + 1];
                                for (int i = 0; i < N; i++) {
                                        count[a[i].charAt(d) + 1]++;
                                }

                                for (int r = 0; r < R; r++) {
                                        count[r + 1] += count[r];
                                }

                                for (int i = 0; i < N; i++) {
                                        aux[count[a[i].charAt(d)]++] = a[i];
                                }

                                for (int i = 0; i < N; i++) {
                                        a[i] = aux[i];
                                }
                        }
                }
                
========================================================================

<h3>上面的python代码</h3>

        import random,numpy as np
        r={}                    #r是字符串0-9a-z指向0-36的字典
        for i in range(10):
            r[str(i)]=i
        for i in range(97,97+26):
            r[chr(i)]=i-87
        d=np.random.choice(list(r.keys()),size=(33,3)).tolist()
        d=list(map(''.join,d))

        def sor1(d,w):
            for  x in range(w,-1,-1):
                le=len(d)
                l=[0]*(len(r)+1)
                for i in d:
                    l[r[i[x]]+1]+=1
                    
                for i in range(len(l)-1):
                    l[i+1]+=l[i]
                    
                dd=list(range(le))
                
                for i in d:
                    dd[l[r[i[x]]]]=i
                    l[r[i[x]]]+=1
                print('第{}次遍历后：{}'.format(w-x+1,dd))
                d=dd

        sor1(d,len(d[0])-1)

========================================================================

<h3>高位排序。R是字母种类的个数，M是小数组的切换阈值（即数组长度<=M时调用Insertion.sort(a, lo, hi, d)并不再递归），charat用来在s里查找第d个字符串，找不到则返回-1，思路是：
count数组长度是r+2，因为需要额外一个项来保存charAt返回-1的字符串个数。举例说明，count用来记录a到d4个字母的数量，则count的长度是6，charAt是{a:0,b:1,c:2,d:3，None:-1}，所以循环a1完成后count=[0，numNone，numa,numb,numc,numd]，循环a2完成后count=[0，numNone，numa+numNone,numb+numa+numNone,numc+numb+numa+numNone,numd+numc+numb+numa+numNone（这一项也等于hi-lo+1，即数组被遍历部分的长度）]，循环a3是将a排序到aux，完成后后count=[numNone，numa+numNone,numb+numa+numNone,numc+numb+numa+numNone,hi-lo+1，hi-lo+1]，循环a4是将aux按顺序复制回a，此时a已经被排序，此时count的各个值正是a被分成各个值对应的块的起点和终点-1，例如最开始是None部分，个数等于numNone，，所以最后一个None是numNone-1，正好等于count（0）-1，第二部分是a开头的部分，第一个是numNone（正好等于count（0）），个数是numa，所以最后一个是numNone+numa-1，正好等于count（1）-1，循环a5是将a的这些块递归排序，所以写成sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1）。对于相同的字符串速度很慢，因为这些项会一直在同一个数组里被复制粘贴，不被修改，知道寻找超过它们长度的字符时被移到count（0）区域被删除</h3>

        public class MSD {
                private static int R = 256;
                private static final int M = 15;
                private static String[] aux;

                private static int charAt(String s, int d) {
                        if (d < s.length()) {
                                return s.charAt(d);
                        } else {
                                return -1;
                        }
                }

                public static void sort(String[] a) {
                        int N = a.length;
                        aux = new String[N];
                        sort(a, 0, N - 1, 0);
                }

                private static void sort(String[] a, int lo, int hi, int d) {
                        // 以第d个字符为键将a[lo]至a[hi]排序
                        if (hi <= lo + M) {
                                Insertion.sort(a, lo, hi, d);
                                return;
                        }
                        int[] count = new int[R + 2];
                        for (int i = lo; i <= hi; i++) {                #循环a1
                                count[charAt(a[i], d) + 2]++;
                        }

                        for (int r = 0; r < R + 1; r++) {                 #循环a2
                                count[r + 1] += count[r];
                        }

                        for (int i = lo; i <= hi; i++) {                 #循环a3
                                aux[count[charAt(a[i], d) + 1]++] = a[i];
                        }

                        for (int i = lo; i <= hi; i++) {                 #循环a4
                                a[i] = aux[i - lo];
                        }

                        for (int r = 0; r < R; r++) {                    #循环a5
                                sort(a, lo + count[r], lo + count[r + 1] - 1, d + 1);
                        }
                }
        }
        
<h4>小数组调用的 Insertion.sort()，思路就是第二章的交换排序</h4>

        public class Insertion {
                public static void sort(String[] a, int lo, int hi, int d) {
                        // 从第d个字符开始对a[lo]到a[hi]排序
                        for (int i = lo; i <= hi; i++) {
                                for (int j = i; j > lo && less(a[j], a[j - 1], d); j--) {
                                        exch(a, j, j - 1);
                                }
                        }
                }

                private static boolean less(String v, String w, int d) {
                        return v.substring(d).compareTo(w.substring(d)) < 0;
                }

                private static void exch(String[] a, int i, int j) {
                        String temp = a[i];
                        a[i] = a[j];
                        a[j] = temp;
                }
        }

========================================================================

