<h3>图的构造</h3>

	public class Graph {
	      private final int V;
	      private int E;
	      private Bag<Integer>[] adj;

	       #生成全是空值的图

	      public Graph(int V) {
		this.V = V;
		this.E = 0;
		adj = (Bag<Integer>[]) new Bag[V];
		for (int v = 0; v < V; v++) {
		  adj[v] = new Bag<Integer>();
		}
	      }

	       #通过输入生成图

	      public Graph(In in) {
		this(in.readInt());         #得到空图
		int E = in.readInt();
		for (int i = 0; i < E; i++) {
		  int v = in.readInt();         #每次读两个整数，通过addEdge添加进图
		  int w = in.readInt();
		  addEdge(v, w);
		}
	      }

	      public Graph(Graph G) {     #？？？？
		this(G.V());
		E = G.E();
		for (int v = 0; v < G.V(); v++) {
		  Stack<Integer> reverse = new Stack<>();
		  for (int w : G.adj[v]) {
		    reverse.push(w);
		  }
		  for (int w : reverse) {
		    adj[v].add(w);
		  }
		}
	      }

	      public int V() {
		return V;
	      }

	      public int E() {
		return E;
	      }

	      public void addEdge(int v, int w) {   #在v的邻接点里加入w，在w的邻接点里加入v，边数e+=1
		adj[v].add(w);
		adj[w].add(v);
		E++;
	      }

	      public Iterable<Integer> adj(int v) {
		return adj[v];
	      }

	      @Override
	      public String toString() {
		String s = V + " vertices, " + E + " edges\n";
		for (int v = 0; v < V; v++) {
		  s += v + ": ";
		  for (int w : this.adj(v)) {
		    s += w + " ";
		  }
		  s += "\n";
		}
		return s;
	      }
    }

========================================================================

<h3>深度优先搜索</h3>

    public class DepthFirstPaths {
	      private boolean[] marked;
	      private int[] edgeTo;
	      private final int s;

	      public DepthFirstPaths(Graph G, int s) {
		marked = new boolean[G.V()];          #marked数组用来存储该点是否和s相连通
		edgeTo = new int[G.V()];              #用来标记该点的上一个顶点，顺序跟图的表示，图的结构和递归性质有关，可操作但具体不明
		this.s = s;
		dfs(G, s);
	      }

	      private void dfs(Graph G, int v) {    #方法是：某条路走到尽头/重复点后返回上一个分歧
		marked[v] = true;               #每到一个点就标记连通
		for (int w : G.adj(v)) {
		  if (!marked[w]) {           #如果不连通就遍历该点
		    edgeTo[w] = v;            
		    dfs(G, w);
		  }
		}
	      }

	      public boolean hasPathTo(int v) {       
		return marked[v];
	      }

	      public Iterable<Integer> pathTo(int v) {     #将s-v的路径压入path，并按顺序return
		if (!hasPathTo(v)) {
		  return null;
		}
		Stack<Integer> path = new Stack<Integer>();  
		for (int x = v; x != s; x = edgeTo[x]) {
		  path.push(x);
		}
		path.push(s);
		return path;
	      }

	      public static void main(String[] args) {
		Graph G = new Graph(new In(args[0]));
		int s = Integer.parseInt(args[1]);
		DepthFirstPaths search = new DepthFirstPaths(G, s);
		for (int v = 0; v < G.V(); v++) {
		  StdOut.print(s + " to " + v + ": ");
		  if (search.hasPathTo(v)) {
		    for (int x : search.pathTo(v)) {
		      if (x == s) {
			StdOut.print(x);
		      } else {
			StdOut.print("-" + x);
		      }
		    }
		  }
		  StdOut.println();
		}
	      }
    }
  
 ============================================================================

	public class BreadthFirstPaths {
		private boolean[] marked;
		private int[] edgeTo;
		private int[] distTo; // Add for Exercise 4.1.13
		private final int s;

		public BreadthFirstPaths(Graph G, int s) {
			marked = new boolean[G.V()];
			edgeTo = new int[G.V()];
			distTo = new int[G.V()]; // Add for Exercise 4.1.13
			this.s = s;
			bfs(G, s);
		}

		private void bfs(Graph G, int s) {
			Queue<Integer> queue = new Queue<Integer>();
			marked[s] = true;
			// Add for Exercise 4.1.13
			for (int v = 0; v < G.V(); v++) {
				distTo[v] = Integer.MAX_VALUE;
			}
			distTo[s] = 0;
			queue.enqueue(s);
			while (!queue.isEmpty()) {
				int v = queue.dequeue();
				for (int w : G.adj(v)) {
					if (!marked[w]) {
						edgeTo[w] = v;
						marked[w] = true;
						distTo[w] = distTo[v] + 1; // Add for Exercise 4.1.13
						queue.enqueue(w);
					}
				}
			}
		}

		public boolean hasPathTo(int v) {
			return marked[v];
		}

		public Iterable<Integer> pathTo(int v) {
			if (!hasPathTo(v)) {
				return null;
			}
			Stack<Integer> path = new Stack<Integer>();
			for (int x = v; x != s; x = edgeTo[x]) {
				path.push(x);
			}
			path.push(s);
			return path;
		}

		/**
		 * Exercise 4.1.13
		 * 
		 * @param v
		 * @return
		 */
		public int distTo(int v) {
			return distTo[v];
		}

		public static void main(String[] args) {
			Graph G = new Graph(new In(args[0]));
			int s = Integer.parseInt(args[1]);
			BreadthFirstPaths search = new BreadthFirstPaths(G, s);
			for (int v = 0; v < G.V(); v++) {
				StdOut.print(s + " to " + v + ": ");
				if (search.hasPathTo(v)) {
					for (int x : search.pathTo(v)) {
						if (x == s) {
							StdOut.print(x);
						} else {
							StdOut.print("-" + x);
						}
					}
				}
				StdOut.println();
			}
		}
	}
