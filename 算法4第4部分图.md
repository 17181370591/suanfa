<h3>图的构造</h3>

	public class Graph {
	      private final int V;
	      private int E;
	      private Bag<Integer>[] adj;

	       #生成全是空值的图

	      public Graph(int V) {
		this.V = V;
		this.E = 0;
		adj = (Bag<Integer>[]) new Bag[V];
		for (int v = 0; v < V; v++) {
		  adj[v] = new Bag<Integer>();
		}
	      }

	       #通过输入生成图

	      public Graph(In in) {
		this(in.readInt());         #得到空图
		int E = in.readInt();
		for (int i = 0; i < E; i++) {
		  int v = in.readInt();         #每次读两个整数，通过addEdge添加进图
		  int w = in.readInt();
		  addEdge(v, w);
		}
	      }

	      public Graph(Graph G) {     #？？？？
		this(G.V());
		E = G.E();
		for (int v = 0; v < G.V(); v++) {
		  Stack<Integer> reverse = new Stack<>();
		  for (int w : G.adj[v]) {
		    reverse.push(w);
		  }
		  for (int w : reverse) {
		    adj[v].add(w);
		  }
		}
	      }

	      public int V() {
		return V;
	      }

	      public int E() {
		return E;
	      }

	      public void addEdge(int v, int w) {   #在v的邻接点里加入w，在w的邻接点里加入v，边数e+=1
		adj[v].add(w);
		adj[w].add(v);
		E++;
	      }

	      public Iterable<Integer> adj(int v) {
		return adj[v];
	      }

	      @Override
	      public String toString() {
		String s = V + " vertices, " + E + " edges\n";
		for (int v = 0; v < V; v++) {
		  s += v + ": ";
		  for (int w : this.adj(v)) {
		    s += w + " ";
		  }
		  s += "\n";
		}
		return s;
	      }
    }

========================================================================

<h3>深度优先搜索</h3>

    public class DepthFirstPaths {
	      private boolean[] marked;
	      private int[] edgeTo;
	      private final int s;

	      public DepthFirstPaths(Graph G, int s) {
		marked = new boolean[G.V()];          #marked数组用来存储该点是否和s相连通
		edgeTo = new int[G.V()];   
		 #用来标记该点的上一个顶点，顺序跟图的表示，图的结构和递归性质有关，可操作但具体不明
		this.s = s;
		dfs(G, s);
	      }

	      private void dfs(Graph G, int v) {    #方法是：某条路走到尽头/重复点后返回上一个分歧
		marked[v] = true;               #每到一个点就标记连通
		for (int w : G.adj(v)) {
		  if (!marked[w]) {           #如果不连通就遍历该点
		    edgeTo[w] = v;            
		    dfs(G, w);
		  }
		}
	      }

	      public boolean hasPathTo(int v) {       
		return marked[v];
	      }

	      public Iterable<Integer> pathTo(int v) {     #将s-v的路径压入path，并按顺序return
		if (!hasPathTo(v)) {
		  return null;
		}
		Stack<Integer> path = new Stack<Integer>();  
		for (int x = v; x != s; x = edgeTo[x]) {
		  path.push(x);
		}
		path.push(s);
		return path;
	      }

	      public static void main(String[] args) {
		Graph G = new Graph(new In(args[0]));
		int s = Integer.parseInt(args[1]);
		DepthFirstPaths search = new DepthFirstPaths(G, s);
		for (int v = 0; v < G.V(); v++) {
		  StdOut.print(s + " to " + v + ": ");
		  if (search.hasPathTo(v)) {
		    for (int x : search.pathTo(v)) {
		      if (x == s) {
			StdOut.print(x);
		      } else {
			StdOut.print("-" + x);
		      }
		    }
		  }
		  StdOut.println();
		}
	      }
    }
  
 ============================================================================

<h3>广度优先搜索</h3>

	public class BreadthFirstPaths {
		private boolean[] marked;
		private int[] edgeTo;
		private int[] distTo; 		// Add for Exercise 4.1.13
		private final int s;

		public BreadthFirstPaths(Graph G, int s) {
			marked = new boolean[G.V()];
			edgeTo = new int[G.V()];
			distTo = new int[G.V()]; 	// Add for Exercise 4.1.13
			this.s = s;
			bfs(G, s);
		}

		private void bfs(Graph G, int s) {
			Queue<Integer> queue = new Queue<Integer>();
			marked[s] = true;
			// Add for Exercise 4.1.13
			for (int v = 0; v < G.V(); v++) {
				distTo[v] = Integer.MAX_VALUE;
			}
			distTo[s] = 0;
			queue.enqueue(s);
			while (!queue.isEmpty()) {
				int v = queue.dequeue();
				for (int w : G.adj(v)) {
					if (!marked[w]) {
						edgeTo[w] = v;
						marked[w] = true;
						distTo[w] = distTo[v] + 1; // Add for Exercise 4.1.13
						queue.enqueue(w);
					}
				}
			}
		}

		public boolean hasPathTo(int v) {
			return marked[v];
		}

		public Iterable<Integer> pathTo(int v) {
			if (!hasPathTo(v)) {
				return null;
			}
			Stack<Integer> path = new Stack<Integer>();
			for (int x = v; x != s; x = edgeTo[x]) {
				path.push(x);
			}
			path.push(s);
			return path;
		}

							/**
							 * Exercise 4.1.13
							 * 
							 * @param v
							 * @return
							 */
		public int distTo(int v) {
			return distTo[v];
		}

		public static void main(String[] args) {
			Graph G = new Graph(new In(args[0]));
			int s = Integer.parseInt(args[1]);
			BreadthFirstPaths search = new BreadthFirstPaths(G, s);
			for (int v = 0; v < G.V(); v++) {
				StdOut.print(s + " to " + v + ": ");
				if (search.hasPathTo(v)) {
					for (int x : search.pathTo(v)) {
						if (x == s) {
							StdOut.print(x);
						} else {
							StdOut.print("-" + x);
						}
					}
				}
				StdOut.println();
			}
		}
	}

 ============================================================================
 
 <h3>前三个的python代码</h3>
 
	import queue

	class Tree(object):

	    #将点数，边数，邻接点传入
	    def __init__(self,v,e,l):
		self.V=v
		self.E=e
		self.myv=[[]]       #每个顶点的邻接点的list
		self.pre=[None]*self.V      #深度优先搜索的上个顶点的list
		self.pred=[None]*self.V     #广度优先搜索的上个顶点的list
		self.pred[0]=0              #不设置为0的话，第一个点会找到它第一个被遍历的顶点
		self.marked=[False]*self.V  #在深度优先搜索中检查是否遍历过
		for i in range(self.V-1):   #为myv的每个值创建空list
		    self.myv.append([])
		for w,v in l:
		    self.addEdge(w,v)

	    def addEdge(self,w,v):      #将邻接点的信息写入，通过adj获取某个点的所以邻接点
		self.myv[w].append(v)
		self.myv[v].append(w)

	    def adj(self,s):
		return self.myv[s]

	    def depth(self,s):          #深度优先搜索
		self.marked[s]=True
		for i in self.adj(s):
		    if not  self.marked[i]:
			self.pre[i]=s
			self.depth(i)

	    def breadth(self,s):
		#广度优先搜索：从顶点出发，将找到的临接点里没有被遍历过的点（遍历过的点pred有值）加入队列q，
		#并修改这些点的pred(写入该点的上个顶点），然后按写入顺序找这些点的临接点，直到q变空
		q=queue.Queue()
		q.put(s)
		while q.qsize():
		    x=q.get()
		    for i in self.adj(x):
			if self.pred[i] is None:
			    q.put(i)
			    self.pred[i]=x

	    def path_to_depth(self,s,l):    #传入要找的点和搜索方式，返回该点到根顶点的路径
		if int(s) not in range(self.V):
		    return 'out of range'
		if not self.marked[s]:
		    return 'no way'
		p=[str(s)]
		while  s>0:
		    s=l[s]
		    p.append(str(s))
		return '-'.join(p)


	if __name__=='__main__':
	    l=((0,1),(0,2),(0,5),(1,2),(2,4),(2,3),(3,4),(5,3))
	    t=Tree(7,8,l)
	    t.depth(0)
	    print(t.pre,'\n',t.myv,'\n',t.marked)
	    print(t.path_to_depth(4,t.pre))
	    t.breadth(0)
	    print(t.pred,t.path_to_depth(5,t.pred))

 ============================================================================
 
